[
["langage-r-et-interface-rstudio.html", "Chapitre 3 Langage R et interface Rstudio 3.1 Introduction et objectifs (à compléter) 3.2 Langage R 3.3 Rstudio", " Chapitre 3 Langage R et interface Rstudio 3.1 Introduction et objectifs (à compléter) L’objectif de cette séance est une brève présentation du langage de programmation R et de l’interface Rstudio.Il est essentiel de prendre en main cet outil très rapidement pour la réussite des travaux pratiques. Bien entendu, le contenu de cette séance est insuffisant pour cela. Nous donnons quelques pointeurs utiles et libres pour débuter en R. Il est fondamental de les parcourir avant de débuter les travaux pratiques. R pour les débutants (Emmanuel Paradis) Ouvrage en français (Vincent Goulet) Les manuels de R sont plus austères mais on peut les trouver utiles. Introduction à R Liste des fonctions de base. 3.2 Langage R Le langage R est un langage de programmation interprété. Il repose sur l’exécution dynamique du programme par un autre programme (l’interprète écrit en C). À l’origine, R a été développé pour des applications en statistique. Bien qu’il dépasse largement ce cadre, il reste particulièrement intéressant pour la science des données. Le langage s’appuie sur la notion de vecteur, simplifiant le recours aux structures itératives (boucles for, while, etc.). Il n’y a pas de typage ou de déclaration obligatoire des variables. Il permet d’écrires des programmes courts, comportant quelques lignes de code seulement et le temps de développement est réduit. 3.2.1 Utilisation de R Comme tout programme R doit être installé sur le système avant de pouvoir l’utiliser. Il s’agit d’un logiciel libre qu’il est possible de télécharger à partir du site CRAN pour une installation personnelle. R est en premier lieu une application offrant une invite de commande symbolisée par un “prompt” (&gt;). L’utilisation de R en ligne de commande est toutefois restreint, et il est utile pour des opérations très simple. Par exemple, on peut effectuer des opérations de calcul telles que calculer log(3) log(3) ## [1] 1.098612 ou faire la moyenne de 100 nombres pris au hasard entre 0 et 1 x &lt;- runif(100) mean(x) ## [1] 0.5389436 R peut être utilisé sous l’invite du système en mode de traitement par lot (“batch processing”) grâce à la commande R CMD BATCH. Dans la suite, nous utiliserons essentiellement l’exécution de scripts (quelques commandes de R successives) à partir de l’interface Rstudio. Retenons que les principaux modes d’utilisation de R sont les suivants Utilisation en ligne de commande : une commande simple est utilisée en mode interactif. La suite des commandes est enregistrée dans le fichier .Rhistory, et peut être retrouvée par la commande R history(). Utilisation d’un script : un programme court ayant l’extension .R ou .r stocké sur le disque. Les scripts peuvent être exécuté par la commande source() ou en mode batch par R CMD BATCH. Utilisation d’une fonction (routine) : une suite d’instructions effectuant un traitement spécifique bien identifié et pouvant être réutilisée. Utilisation d’une bibliothèque R : un programme écrit en R (et pouvant utiliser d’autres langages) appelé “package” qui rend disponible des fonctions à d’autres projets de programmation en conservant l’intégrité de son implémentation. Nous utiliserons par exemple des bibiothèques de “réseaux neuronaux” qui nous permettront de programmer en quelques lignes de code R des méthodes d’apprentissage statistique très puissantes. Le répertoire de travail (workspace) de R est le dossier par défaut dans lequel le logiciel va rechercher des fichiers de script ou de données et va sauvegarder l’espace de travail dans le fichier .RData. Le répertoire de travail est déterminé au lancement de R. Notons que lorsque l’on quitte R, le logiciel propose de sauver les objets créés pendant la session dans un répertoire local .Rdata. Si l’on accepte, on retrouve la session dans l’état où on la quitte lorsque l’on relançe le logiciel. 3.2.2 Principales classes d’objets Dans le langage R, toute forme de donnée appelée objet. Les variables, les fonctions, les opérateurs, même le symbole représentant le nom d’un objet est un objet. Les objets possèdent au minimum un mode (ou classe) et une longueur. Les principales classes d’objet sont les suivantes “numeric” : un vecteur contenant des valeurs numériques “character” : un vecteur contenant des caractères ou des chaînes de caractères “logical” : un vecteur contenant des valeurs 0/1 “matrix” : un vecteur contenant des valeurs numériques, codé comme une matrice comportant \\(n\\) lignes et \\(p\\) colonnes. “list” : une liste d’objets potentiellement hétérogène, comportant par exemple des vecteurs, des matrices, des caractères. “data.frame” : une liste d’objets de même longueur. “function” : une fonction Par exemple, supposons que la variable \\(x\\) prenne la valeur 8. x &lt;- 8 x ## [1] 8 Nous voyons que x est un vecteur dont la première valeur est égale à 1. x[1] ## [1] 8 Nous vérifions que le vecteur x est de longueur 1 et de classe “numeric”. length(x) ## [1] 1 class(x) ## [1] &quot;numeric&quot; Pour créer une liste, on peut utiliser la fonction liste. La plupart des objets manipulés par les bibiothèques R sont des listes. Les différents attributs d’une liste sont accessibles par le symbole dollar ($) ou par le double crochet. mes_betes &lt;- list(animal = c(&quot;chat&quot;, &quot;chien&quot;), sex = c(&quot;M&quot;, &quot;F&quot;), age = c(2, 8), vaccine = c(TRUE, TRUE) ) Pour obtenir les attributs, on pourra utiliser le symbole dollar mes_betes ## $animal ## [1] &quot;chat&quot; &quot;chien&quot; ## ## $sex ## [1] &quot;M&quot; &quot;F&quot; ## ## $age ## [1] 2 8 ## ## $vaccine ## [1] TRUE TRUE Ainsi mes_betes$animal ## [1] &quot;chat&quot; &quot;chien&quot; On pourra alors corriger les erreurs éventuelles. Si le second animal est un perroquet mes_betes$animal[2] &lt;- &quot;perroquet&quot; mes_betes ## $animal ## [1] &quot;chat&quot; &quot;perroquet&quot; ## ## $sex ## [1] &quot;M&quot; &quot;F&quot; ## ## $age ## [1] 2 8 ## ## $vaccine ## [1] TRUE TRUE Tout les attributs ont meme longueur. On peut utiliser un tableau de données (data.frame). Un data.frame une liste particulière organisée en colonne. mes_betes &lt;- data.frame(animal = c(&quot;chat&quot;, &quot;perroquet&quot;), sex = c(&quot;M&quot;, &quot;F&quot;), age = c(2, 8), vaccine = c(TRUE, TRUE) ) mes_betes ## animal sex age vaccine ## 1 chat M 2 TRUE ## 2 perroquet F 8 TRUE 3.2.3 Manipulations vectorielles élémentaires Nous décrivons deux exxemples de manipulations vectorielles élémentaires. Tout d’abord, considérons le vecteur suivant x &lt;- c(1,6,7,1,0,9,2,3) x ## [1] 1 6 7 1 0 9 2 3 et supposons que l’on cherche à extraire les valeurs plus grandes que 2. Dans ce cas, nous pouvons créer un vecteur logique (x &gt; 2) ## [1] FALSE TRUE TRUE FALSE FALSE TRUE FALSE TRUE et obtenir le résultat de la manière suivante x[x &gt; 2] ## [1] 6 7 9 3 Nous obtenons les indices vérifiant la condition avec la fonction which which(x &lt; 2) ## [1] 1 4 5 Nous voyons que le calcul vectoriel est équivalent au code suivant utilisant une boucle for et un test y &lt;- NULL n &lt;- length(x) for (i in 1:n){ if (x[i] &gt; 2){ y &lt;- c(y, x[i]) } } y ## [1] 6 7 9 3 Notre deuxième exemple est un plus subtil. Nous créons une matrice de taille 9 fois 11 contenant les premiers entiers et nous cherchons à remplacer les valeurs paires par des valeurs nulles. M &lt;- matrix(1:99, nrow = 9, ncol = 11) # dimensions de la matrice M dim(M) ## [1] 9 11 # element 2,4 M[2,4] ## [1] 29 Puisque les matrices sont des vecteurs, la solution s’écrit tout simplement # le reste de la division s&#39;écrit &quot;%%&quot; M[M %% 2 == 0] &lt;- 0 Nous pouvons vérifier le résultat M ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] ## [1,] 1 0 19 0 37 0 55 0 73 0 91 ## [2,] 0 11 0 29 0 47 0 65 0 83 0 ## [3,] 3 0 21 0 39 0 57 0 75 0 93 ## [4,] 0 13 0 31 0 49 0 67 0 85 0 ## [5,] 5 0 23 0 41 0 59 0 77 0 95 ## [6,] 0 15 0 33 0 51 0 69 0 87 0 ## [7,] 7 0 25 0 43 0 61 0 79 0 97 ## [8,] 0 17 0 35 0 53 0 71 0 89 0 ## [9,] 9 0 27 0 45 0 63 0 81 0 99 3.2.4 Exercice La bibiothèque ‘mlbench’ (machine learning benchmarks) contient des jeux de données que nous pourrons analyser et à partir desquels nous ferons des prédictions. L’exemple BreastCancer contient des données biomédicales concernant le cancer du sein (pour 699 patientes). La fonction data permet de charger les données en mémoire sous forme de tableau (data.frame). Avec la fonction head nous pouvons visualiser les premières lignes du tableau de données. library(&#39;mlbench&#39;) data(BreastCancer) head(BreastCancer) ## Id Cl.thickness Cell.size Cell.shape Marg.adhesion Epith.c.size ## 1 1000025 5 1 1 1 2 ## 2 1002945 5 4 4 5 7 ## 3 1015425 3 1 1 1 2 ## 4 1016277 6 8 8 1 3 ## 5 1017023 4 1 1 3 2 ## 6 1017122 8 10 10 8 7 ## Bare.nuclei Bl.cromatin Normal.nucleoli Mitoses Class ## 1 1 3 1 1 benign ## 2 10 3 2 1 benign ## 3 2 3 1 1 benign ## 4 4 3 7 1 benign ## 5 1 3 1 1 benign ## 6 10 9 7 1 malignant Nous cherchons à récuperer le diagnostic des patientes (colonne Class) et à compter combien de diagnostics sont bénins (“benign”). # les noms des colonnes colnames(BreastCancer) ## [1] &quot;Id&quot; &quot;Cl.thickness&quot; &quot;Cell.size&quot; ## [4] &quot;Cell.shape&quot; &quot;Marg.adhesion&quot; &quot;Epith.c.size&quot; ## [7] &quot;Bare.nuclei&quot; &quot;Bl.cromatin&quot; &quot;Normal.nucleoli&quot; ## [10] &quot;Mitoses&quot; &quot;Class&quot; # On peut obtenir la colonne Class de la manière suivante # On peut aussi remplacer Class par 11 status &lt;- BreastCancer[,&quot;Class&quot;] # méthode alternative : le $ désigne un attribut de liste status &lt;- BreastCancer$Class sum(status == &quot;benign&quot;) ## [1] 458 table(status) ## status ## benign malignant ## 458 241 3.2.5 Fonctions de base En chargeant R, on charge des centaines de fonctions de base contenues dans les bibliothèques base, stats, graphics, etc, chargées par défaut. apply(M, MARGIN = 2, sum) ## [1] 25 56 115 128 205 200 295 272 385 344 475 colSums(M) ## [1] 25 56 115 128 205 200 295 272 385 344 475 3.2.6 Bonnes pratiques Data Codes Doc Comptes_Rendus Suivre recommendations en matière de nomenclature pour l’écriture de code (Coding style) indentation commentaires 3.3 Rstudio 3.3.1 Projets 3.3.2 Notebooks (Rmd) 3.3.3 Bonnes pratiques projet "]
]
