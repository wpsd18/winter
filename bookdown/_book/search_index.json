[
["langage-r-et-interface-rstudio.html", "Chapitre 3 Langage R et interface Rstudio 3.1 Introduction et objectifs (à compléter) 3.2 Langage R 3.3 Rstudio", " Chapitre 3 Langage R et interface Rstudio 3.1 Introduction et objectifs (à compléter) L’objectif de cette séance est une brève présentation du langage de programmation R et de l’interface Rstudio.Il est essentiel de prendre en main cet outil très rapidement pour la réussite des travaux pratiques. Bien entendu, le contenu de cette séance est insuffisant pour cela. Nous donnons quelques pointeurs utiles et libres pour débuter en R. Il est fondamental de les parcourir avant de débuter les travaux pratiques. R pour les débutants (Emmanuel Paradis) Ouvrage en français (Vincent Goulet) Les manuels de R sont plus austères mais on peut les trouver utiles. Introduction à R Liste des fonctions de base. 3.2 Langage R Le langage R est un langage de programmation interprété. Il repose sur l’exécution dynamique du programme par un autre programme (l’interprète écrit en C). À l’origine, R a été développé pour des applications en statistique. Bien qu’il dépasse largement ce cadre, il reste particulièrement intéressant pour la science des données. Le langage s’appuie sur la notion de vecteur, simplifiant le recours aux structures itératives (boucles for, while, etc.). Il n’y a pas de typage ou de déclaration obligatoire des variables. Il permet d’écrires des programmes courts, comportant quelques lignes de code seulement et le temps de développement est réduit. 3.2.1 Utilisation de R Comme tout programme R doit être installé sur le système avant de pouvoir l’utiliser. Il s’agit d’un logiciel libre qu’il est possible de télécharger à partir du site CRAN pour une installation personnelle. R est en premier lieu une application offrant une invite de commande symbolisée par un “prompt” (&gt;). L’utilisation de R en ligne de commande est toutefois restreint, et il est utile pour des opérations très simple. Par exemple, on peut effectuer des opérations de calcul telles que calculer log(3) log(3) ## [1] 1.098612 ou faire la moyenne de 100 nombres pris au hasard entre 0 et 1 x &lt;- runif(100) mean(x) ## [1] 0.4570041 R peut être utilisé sous l’invite du système en mode de traitement par lot (“batch processing”) grâce à la commande R CMD BATCH. Dans la suite, nous utiliserons essentiellement l’exécution de scripts (quelques commandes de R successives) à partir de l’interface Rstudio. Retenons que les principaux modes d’utilisation de R sont les suivants Utilisation en ligne de commande : une commande simple est utilisée en mode interactif. La suite des commandes est enregistrée dans le fichier .Rhistory, et peut être retrouvée par la commande R history(). Utilisation d’un script : un programme court ayant l’extension .R ou .r stocké sur le disque. Les scripts peuvent être exécuté par la commande source() ou en mode batch par R CMD BATCH. Utilisation d’une fonction (routine) : une suite d’instructions effectuant un traitement spécifique bien identifié et pouvant être réutilisée. Utilisation d’une bibliothèque R : un programme écrit en R (et pouvant utiliser d’autres langages) appelé “package” qui rend disponible des fonctions à d’autres projets de programmation en conservant l’intégrité de son implémentation. Nous utiliserons par exemple des bibiothèques de “réseaux neuronaux” qui nous permettront de programmer en quelques lignes de code R des méthodes d’apprentissage statistique très puissantes. Le répertoire de travail (workspace) de R est le dossier par défaut dans lequel le logiciel va rechercher des fichiers de script ou de données et va sauvegarder l’espace de travail dans le fichier .RData. Le répertoire de travail est déterminé au lancement de R. Notons que lorsque l’on quitte R, le logiciel propose de sauver les objets créés pendant la session dans un répertoire local .Rdata. Si l’on accepte, on retrouve la session dans l’état où on la quitte lorsque l’on relançe le logiciel. 3.2.2 Principales classes d’objets Dans le langage R, toute forme de donnée appelée objet. Les variables, les fonctions, les opérateurs, même le symbole représentant le nom d’un objet est un objet. Les objets possèdent au minimum un mode (ou classe) et une longueur. Les principales classes d’objet sont les suivantes “numeric” : un vecteur contenant des valeurs numériques “character” : un vecteur contenant des caractères ou des chaînes de caractères “logical” : un vecteur contenant des valeurs 0/1 “matrix” : un vecteur contenant des valeurs numériques, codé comme une matrice comportant \\(n\\) lignes et \\(p\\) colonnes. “list” : une liste d’objets potentiellement hétérogènes, contenant par exemple des vecteurs, des matrices, des caractères. “data.frame” : une liste d’objets de même longueur organisée en tableau. “function” : une fonction Par exemple, supposons que la variable \\(x\\) prenne la valeur 8. x &lt;- 8 x ## [1] 8 Nous voyons que x est un vecteur dont la première valeur est égale à 1. x[1] ## [1] 8 Nous vérifions que le vecteur x est de longueur 1 et de classe “numeric”. length(x) ## [1] 1 class(x) ## [1] &quot;numeric&quot; Pour créer une liste, on peut utiliser la fonction liste. La plupart des objets manipulés par les bibiothèques R sont des listes. Les différents attributs d’une liste sont accessibles par le symbole dollar ($) ou par le double crochet. mes_betes &lt;- list(animal = c(&quot;chat&quot;, &quot;chien&quot;), sex = c(&quot;M&quot;, &quot;F&quot;), age = c(2, 8), vaccine = c(TRUE, TRUE) ) Pour obtenir les attributs, on pourra utiliser le symbole dollar mes_betes ## $animal ## [1] &quot;chat&quot; &quot;chien&quot; ## ## $sex ## [1] &quot;M&quot; &quot;F&quot; ## ## $age ## [1] 2 8 ## ## $vaccine ## [1] TRUE TRUE Ainsi mes_betes$animal ## [1] &quot;chat&quot; &quot;chien&quot; On pourra alors corriger les erreurs éventuelles. Si le second animal est un perroquet mes_betes$animal[2] &lt;- &quot;perroquet&quot; mes_betes ## $animal ## [1] &quot;chat&quot; &quot;perroquet&quot; ## ## $sex ## [1] &quot;M&quot; &quot;F&quot; ## ## $age ## [1] 2 8 ## ## $vaccine ## [1] TRUE TRUE Remarquons que tous les attributs ont la même longueur. Plutôt que le format de liste, nous pouvons organiser les données sous la forme d’un tableau (data.frame). Un objet de type data.frame est une liste particulière organisée en colonnes. Un data.frame peut être créé de la manière suivante. # les noms sont donnés aux colonnes du tableau de données mes_betes &lt;- data.frame(animal = c(&quot;chat&quot;, &quot;perroquet&quot;), sex = c(&quot;M&quot;, &quot;F&quot;), age = c(2, 8), vaccine = c(TRUE, TRUE)) mes_betes ## animal sex age vaccine ## 1 chat M 2 TRUE ## 2 perroquet F 8 TRUE 3.2.3 Manipulations vectorielles élémentaires Le langage R permet de nombreuses manipulations vectorielles. Nous décrivons ci-dessous deux exemples de manipulations vectorielles élémentaires. Dans le premier exemple, nous chercherons à extraire les éléments d’un vecteur satisfaisant une condition particulière (valeurs supérieures à deux). Dans le deuxième exemple, nous remplacerons certains éléments d’une matrice par des valeurs nulles. Tout d’abord, considérons le vecteur suivant (notons que ) x &lt;- c(1,6,7,1,0,9,2,3) # c() permet de créer un vecteur x ## [1] 1 6 7 1 0 9 2 3 Supposons que l’on cherche à extraire les valeurs plus grandes que 2 du vecteur x. Dans ce cas, nous pouvons créer un vecteur logique (x &gt; 2) ## [1] FALSE TRUE TRUE FALSE FALSE TRUE FALSE TRUE et obtenir le résultat de la manière suivante x[x &gt; 2] ## [1] 6 7 9 3 Nous obtenons les indices vérifiant la condition (x&gt;2) avec la fonction which which(x &lt; 2) ## [1] 1 4 5 Nous voyons que le calcul vectoriel est équivalent au code suivant utilisant une boucle for et un test y &lt;- NULL # initialiser la variable résultat par l&#39;objet &quot;NULL&quot; n &lt;- length(x) for (i in 1:n){ # 1:n est un vecteur de valeurs de 1 à n if (x[i] &gt; 2){ y &lt;- c(y, x[i]) } } print(y) # on pourrait simplement écrire &quot;y&quot; ## [1] 6 7 9 3 Notre deuxième exemple est un plus subtil. Nous créons une matrice de taille 9 fois 11 contenant les 99 premiers entiers et nous cherchons à remplacer les valeurs paires de cette matrice par des valeurs nulles. M &lt;- matrix(1:99, nrow = 9, ncol = 11) dim(M) # dimensions de la matrice M ## [1] 9 11 print(M[2,4]) # affiche l&#39;élément [2,4] de la matrice ## [1] 29 Puisque les matrices sont codées comme des vecteurs, la solution s’écrit tout simplement M[M %% 2 == 0] &lt;- 0 # le reste de la division (modulo) s&#39;écrit &quot;%%&quot; Nous pouvons vérifier le résultat M ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] ## [1,] 1 0 19 0 37 0 55 0 73 0 91 ## [2,] 0 11 0 29 0 47 0 65 0 83 0 ## [3,] 3 0 21 0 39 0 57 0 75 0 93 ## [4,] 0 13 0 31 0 49 0 67 0 85 0 ## [5,] 5 0 23 0 41 0 59 0 77 0 95 ## [6,] 0 15 0 33 0 51 0 69 0 87 0 ## [7,] 7 0 25 0 43 0 61 0 79 0 97 ## [8,] 0 17 0 35 0 53 0 71 0 89 0 ## [9,] 9 0 27 0 45 0 63 0 81 0 99 3.2.4 Application à un jeu de données La bibiothèque ‘mlbench’ (“machine learning benchmarks”) contient des jeux de données que nous pouvons analyser et à partir desquels nous pourrons faire des prédictions. L’exemple BreastCancer contient des données biomédicales concernant le cancer du sein (les données concernent 699 patientes). La fonction data permet de charger les données en mémoire sous forme de tableau (data.frame). Avec la fonction head nous pouvons visualiser les premières lignes du tableau BreastCancer. library(&#39;mlbench&#39;) data(BreastCancer) head(BreastCancer) ## Id Cl.thickness Cell.size Cell.shape Marg.adhesion Epith.c.size ## 1 1000025 5 1 1 1 2 ## 2 1002945 5 4 4 5 7 ## 3 1015425 3 1 1 1 2 ## 4 1016277 6 8 8 1 3 ## 5 1017023 4 1 1 3 2 ## 6 1017122 8 10 10 8 7 ## Bare.nuclei Bl.cromatin Normal.nucleoli Mitoses Class ## 1 1 3 1 1 benign ## 2 10 3 2 1 benign ## 3 2 3 1 1 benign ## 4 4 3 7 1 benign ## 5 1 3 1 1 benign ## 6 10 9 7 1 malignant Nous cherchons à récupérer l’ensemble des diagnostics des patientes (colonne Class) et souhaitons compter le nombre de diagnostics bénins (“benign”). colnames(BreastCancer) # les noms des colonnes ## [1] &quot;Id&quot; &quot;Cl.thickness&quot; &quot;Cell.size&quot; ## [4] &quot;Cell.shape&quot; &quot;Marg.adhesion&quot; &quot;Epith.c.size&quot; ## [7] &quot;Bare.nuclei&quot; &quot;Bl.cromatin&quot; &quot;Normal.nucleoli&quot; ## [10] &quot;Mitoses&quot; &quot;Class&quot; # On peut obtenir la colonne Class de la manière suivante # On peut aussi remplacer Class par 11 status &lt;- BreastCancer[,&quot;Class&quot;] # Méthode alternative : le $ désigne un attribut de liste status &lt;- BreastCancer$Class Le résultat est donné par la commande suivante sum(status == &quot;benign&quot;) ## [1] 458 Notons qu’il est aussi possible utiliser la fonction table qui crée un histogramme des données de manière automatique table(status) # help(table) ## status ## benign malignant ## 458 241 3.2.5 Fonctions de base La programmation en R s’appuie sur l’utilisation de fonctions et l’utilisation de l’aide en ligne (fonction help()). La structure d’une fonction est la suivante f &lt;- function(arg){ # body } Des centaines de fonctions de base sont contenues dans les bibliothèques base, stats, graphics, etc, chargées par défaut en lançant R. Il est impossible d’énumérer l’ensemble de ces fonctions. C’est en pratiquant régulièrement l’écriture de commandes, en utilisant l’aide, les tutoriaux en ligne (vignettes) et internet que l’on progresse le plus vite dans l’apprentissage des fonctions de base. Des applications web aux graphiques les plus élaborés en passant par des maths de haut niveau, tout est réalisable en R. Voici quelques fonctions clés. Pour lire des données locales ou distantes ou pour les écrire, nous pouvons utiliser les fonctions suivantes * read.table(), write.table() * scan(), write() * read.csv2(), write.csv() Pour effectuer des calculs statistiques de base, nous pouvons utiliser les fonctions suivantes mean(), median(), sd() table(), hist(), pie() Pour effectuer des tirages aléatoires, nous pouvons utiliser les fonctions suivantes sample() pour un tirage d’urne rnorm() pour un tirage de loi normale runif() pour un tirage de loi uniforme La fonction apply() est particulièrement importante car elle permet d’appliquer une fonction aux lignes ou aux colonnes d’une matrice ou d’un tableau, évitant ainsi le recours à une boucle for(). Par exemple, nous souhaitons calculer la somme des valeurs de chaque colonne de la matrice M. apply(M, MARGIN = 2, FUN = sum) ## [1] 25 56 115 128 205 200 295 272 385 344 475 En R, il est aussi possible de calculer ceci directement colSums(M) ## [1] 25 56 115 128 205 200 295 272 385 344 475 Finalement, notons l’usage de la fonction pipe de la bibliothèque magrittr. Un peu comme le “pipe” sous Unix/Linux, cette opérateur permet d’organiser séquentiellement les traitements à effectuer et gagne en lisibilité. Pour reproduire l’exemple précédent, nous pouvons écrire library(magrittr) M %&gt;% colSums() # M est passée en argument à la fonction colSums ## [1] 25 56 115 128 205 200 295 272 385 344 475 Si on souhaite calculer la moyenne du sinus de nombres aléatoires pris entre 0 et 2, il suffit de lire la phrase à l’envers et d’écrire runif(10000, 0, 2) %&gt;% sin() %&gt;% mean() ## [1] 0.7064298 Cette opération évite les appels imbriqués et rend le code plus lisible. Elle est équivalente à la commande suivante mean(sin(runif(10000, 0, 2))) ## [1] 0.6993657 3.2.6 Bonnes pratiques pour les travaux pratiques Programmer en R ou dans un autre langage doit permettre à un autre programmeur ou un autre utilisateur de comprendre l’organisation d’un projet, et généralement de faciliter la reproductibilité du travail effectué. Pour cela, une clé est l’organisation de son espace de travail. R possède de très bons outils pour cela (Rstudio). Pour les travaux pratiques, il est important de créer un répertoire pour chaque TP. Le répertoire de travail d’un TP pourra contenir les sous-répertoires suivants Data : un répertoire contenant les données du TP. Codes : un répertoire contenant les scripts ou les cahiers de travail en Rmd. Documents : un répertoire contenant des ressources séparées, par exemple les documents de référence Comptes_Rendus : un répertoire contenant le fichier Il est de plus très important de respecter quelques recommendations en matière de nomenclature pour l’écriture de code. Quelques règles d’écriture peuvent être trouvée en suivant le lien suivant : Coding style. Les codes étant en général très courts, on s’efforcera de commenter systématiquement les instructions des programmes (avec un dièse). Pour les noms de variables, nous utiliserons la convention “Wickham” utilisant des mots en lettres minuscules séparés par des tirets. Par exemple, pour nommer une fonction permettant de dire “Coucou”, on écrira dire_coucou &lt;- function(){ cat(&quot;Coucou \\n&quot;) } dire_coucou() ## Coucou 3.3 Rstudio Rstudio est un programme dont nous nous servirons pour faire les TPs. Il est essentiel de se familiariser rapidement avec l’interface. Deux avantages intéressants que nous tirerons de ce programme est 1) la possibilité d’associer un projet à un espace de travail, 2) la possibilité de rédiger les TPs et les comptes rendus de TP en même temps que l’on effectue le TP en utilisant un Notebook (cahier). R studio est plus qu’une interface graphique. Ce programme permet de coder en R (ou dans un autre langage), d’ouvrir des scripts ou des cahiers, de gérer ses fichiers, de consulter l’aide, d’installer des bibliothèques, d’afficher des graphiques, de gérer le versionnage du projet (git), etc. 3.3.1 Projets Rstudio permet d’associer un “projet” à un espace de travail. Le projet peut être créé dans l’onglet File, en selectionnant File &gt; New Project et en suivant les instructions de l’interface. L’intêret d’un projet de pouvoir retrouver l’environnement de travail tel qu’on le laisse à la fermeture de l’application. Cela permet aussi de changer de projet très facilement et de revenir plus tard. 3.3.2 Notebooks (Rmd) Les cahiers (Notebooks) sont le mode de travail interactif que nous privéligierons en TP. Un cahier est un programme écrit en langage Rmarkdown. Rmarkdown est un langage de balise permettant de mélanger du texte et du code, que l’on exécute à la volée. Il est aussi possible d’intégrer des commandes latex pour inclure des équations, des images ou des liens web et des commandes html. On peut “compiler” un fichier Rmarkdown pour une sortie en PDF ou html. Il est inutile de connaître le langage Rmarkdown à fond. Les fichiers préparés vous permettront de faire les TPs en simplifiant la phase de rédaction. Une feuille d’aide contenant les quelques commandes utiles de Rmarkdown est disponible dans l’onglet Help de Rstudio. L’ensemble de ce cours est écrit en Rmarkdown. "]
]
